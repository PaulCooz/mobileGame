local objects = {
	"banana", "orange"
}
local bonuses = {
	"frozenLime", "waterboomb"
}

local function getObject()
	if percents(40) then
		return bonuses[math.random(#bonuses)]
	else
		return objects[math.random(#objects)]
	end
end

local function maxH(y0)
	return -(y0 * y0) / (2 * gravity.y)
end

local function length(v)
	return -2 * v.x * v.y / gravity.y
end

function init(self)
	msg.post(".", "acquire_input_focus")
	--																		-- Object selection
	local fruit = getObject()

	local sprite = { id = hash(fruit) }										-- set sprite
	msg.post("#sprite", "play_animation", sprite)

	go.set(go.get_id(), "euler.z", randReal(0, 360))

	self.nameFruit = hash(fruit)
	--																		-- Set an object
	local k = 1 + randReal(0, 0.1)
	go.set_scale(go.get_scale() * k)										-- scale +0..10%

	local startY = -100
	local y0 = math.sqrt(-2 * gravity.y * height) * randReal(0.5, 0.7)		-- max height(50-70%)
	self.v = vmath.vector3(0, y0 - startY, 0)

	local startX = randReal(0, width / 3)
	if percents(30) then													-- throw side
		startX = -startX
		self.v.x = -gravity.y * width / (2 * self.v.y) * randReal(1.3, 1.6)
		self.speed = 2
	else																	-- bottom
		self.v.x = -gravity.y * width / (2 * self.v.y) * randReal(0.2, 0.4)
		self.speed = 3
	end
	if percents(50) then
		self.v.x = -self.v.x
		startX = width - startX
	end

	self.time = 0															-- timer
	self.popTime = 0

	go.set_position(vmath.vector3(startX, startY, 0))
end

local function sqr(a) 
	return a * a
end

function update(self, dt)
	local pos = go.get_position()

	if isGameOver then
		if boomb == vmath.vector3(0, 0, 0) then
			msg.post(msg.url(), hash("cut"), { pos = pos - gravity})
		else
			msg.post(msg.url(), hash("cut"), { pos = boomb })
		end
		go.delete()
	end

	local speed = self.speed * dt
	if freeze > 0 then
		if freeze < 1 then
			speed = speed / (2 * math.sin(math.pi * (2 * freeze + 1) / 6))
		else
			speed = speed / 2
		end
	end

	local boom = vmath.vector3(0, 0, 0)
	if boomb ~= vmath.vector3(0, 0, 0) then
		boom = (pos - boomb) / (sqr(pos.x - boomb.x) + sqr(pos.y - boomb.y))
	end

	local move = self.v + boom + gravity * self.time
	pos = pos + move * speed

	if pos.y < -110 then											-- remove
		if self.nameFruit ~= hash("waterboomb") and isGameOver == false then
			currentHearts = currentHearts - 1
			msg.post("mainWindow", hash("setHearts"), { int = currentHearts })
		end

		if currentHearts <= 0 then
			msg.post("mainWindow", hash("gameOver"))
		end

		go.delete()
	end

	self.time = self.time + speed

	if self.popTime ~= 0 then
		local alpha = (self.time - self.popTime) / 4

		if alpha < 1 then
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1 - alpha))
		else
			go.delete()
		end

		return nil
	end

	local nextAngle = go.get(go.get_id(), "euler.z") + 20 * speed			-- rotate
	go.set(go.get_id(), "euler.z", nextAngle)

	local nextScale = go.get_scale() * (1 + speed / 100)					-- rescale
	go.set_scale(nextScale)

	go.set_position(pos)													-- move
end

function on_message(self, message_id, message)
	if message_id == hash("cut") then
		local fruit = string.sub(
			tostring(self.nameFruit),
			8,
			#tostring(self.nameFruit) - 1
		)
		local pos = go.get_position()

		if fruit == "waterboomb" then
			boomb = message.pos
			boombTime = 4.0

			msg.post("mainWindow", hash("gameOver"))
		else
			currentScore = currentScore + 1									-- update score
			msg.post("mainWindow", hash("setScore"), { int = currentScore })

			if currentScore > bestScore then
				msg.post("mainWindow#startScene", hash("updateScore"), { score = currentScore })
			end
																			-- add halves
			local movePos = (pos - message.pos) * self.speed * 0.5

			if fruit == "frozenLime" then
				freeze = 4.0
			end

			local half0 = hash(fruit .. "0")
			local half1 = hash(fruit .. "1")

			factory.create(
				"mainWindow#pushHalves", 
				vmath.vector3(pos.x * randReal(0.9, 1.1), pos.y * randReal(0.9, 1.1), 0),
				nil,
				{ 
					v = self.v * randReal(0.9, 1.1) + movePos,
					time = self.time,
					nameFruit = half0,
					speed = self.speed * 1.5,
					scale = go.get_scale()
				}, 
				go.get_scale()
			)

			factory.create(
				"mainWindow#pushHalves",
				vmath.vector3(pos.x * randReal(0.9, 1.1), pos.y * randReal(0.9, 1.1), 0),
				nil, 
				{
					v = self.v * randReal(0.9, 1.1) + movePos,
					time = self.time,
					nameFruit = half1,
					speed = self.speed * 1.5,
					scale = go.get_scale()
				},
				go.get_scale()
			)

			msg.post("#sprite", "play_animation", { id = hash("pop" .. math.random(0, 2)) })-- clyaksa
			go.set_scale(go.get_scale() * 2.5)
			go.set_position(vmath.vector3(pos.x, pos.y, 1 / sqr(pos.x + pos.y)))
		end
	end
end

local function dist(a, b)													-- manhattan distance
	return math.abs(a.x - b.x) + math.abs(a.y - b.y)
end

local predCursorPos = vmath.vector3()
local predTime = os.clock()
function on_input(self, action_id, action)
	if action_id == hash("touch") and isGameOver == false and self.popTime == 0 then
		local cursorPos = vmath.vector3(action.x, action.y, 0)

		if action.pressed then
			predCursorPos = cursorPos
			predTime = os.clock()
		else
			if dist(go.get_position(), cursorPos) < 100 then
				local cursorSpeed = dist(predCursorPos, cursorPos) / (os.clock() - predTime)
				if cursorSpeed > 500 then
					msg.post(msg.url(), hash("cut"), { pos = cursorPos })
					self.popTime = self.time
				end
			end
			if os.clock() - predTime >= 0.1 then 
				predCursorPos = cursorPos
				predTime = os.clock()
			end
		end
	end
end